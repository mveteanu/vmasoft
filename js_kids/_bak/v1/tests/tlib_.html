<script src="lib/p5.js"></script>
<script src="lib/p5.play.js"></script>
<button id="btnRun">Run</button><br>
<script>

var oSketch;
var GlobalVars = {};

function setup()
{
    createCanvas(600, 300);

    oSketch = Sketch();
    oSketch.wire();

    TestSketch();

    var btn = document.getElementById("btnRun");
    btn.onclick = HandleButtonClick;
}

function HandleButtonClick()
{
    TestSketch();
}

// Show the scene specified by name
function showScene(sceneName, args)
{
    oSketch.showScene(sceneName, args);
}

// Show the next scene in the scenes array
function showNextScene(args)
{
    oSketch.showNextScene(args);
}

// Obtain the public variables of the specified scene
function getPublicVars(sceneName)
{
    return oSketch.getPublicVars(sceneName);
}


function Sketch()
{
    const P5Events = ["mouseClicked", "keyPressed"];
    
    var scenes = [];
    var scene = null;

    // Wire relevant p5.js events, except setup()
    // If you don't call this method, you need to manually wire events
    function wire()
    {
        var o = window;

        // Wire draw manually to improve speed...
        o.draw = draw;

        // This loop will wire automatically all P5 events to each scene like this:
        // o.mouseClicked = function() { handleEvent("mouseClicked"); }
        for(var i = 0; i < P5Events.length; i++)
        {
            let sEvent = P5Events[i]; // let is necesary to set the scope at the level of for
            o[sEvent] = function() { handleEvent(sEvent) };
        }
    }


    // Add a new scene to the sketch
    function addScene(sceneName, sceneCode)
    {
        var foundSceneIndex = findSceneIndex(sceneName);
        if (foundSceneIndex >= 0)
        {
            var foundScene = scenes[foundSceneIndex];
            
            // Cancel adding the scene if it has the same code as the one already added...
            if ( foundScene.sceneCode == sceneCode )
                return;
        }
        
        var oCodeUtils = CodeUtils();
        oCodeUtils.addP5Events(P5Events);

        var fnScene = oCodeUtils.getSceneFunction(sceneCode, sceneName);
        if (!fnScene)
            return;

        // Executes the scene function to return the object with 'pointers' to scene events
        // e.g. loop, mouseClicked, etc.
        var oScene = fnScene();

        var oSceneWrapper = {   sceneName : sceneName,
                                sceneCode : sceneCode,
                                fnScene : fnScene,
                                oScene : oScene,
                                hasLoop : "loop" in oScene,
                                hasEnter : "enter" in oScene,
                                enterExecuted : false
                            };

        if (foundSceneIndex >= 0)
        {
            // Replace the scene
            scenes[foundSceneIndex] = oSceneWrapper;
        }
        else
        {
            // Add the new scene in the scenes array 
            scenes.push(oSceneWrapper);
        }
    }

    // Return the index of a scene in the internal collection
    function findSceneIndex(sceneName)
    {
        for(var i = 0; i < scenes.length; i++)
        {
            var o = scenes[i]; 
            if ( o.sceneName == sceneName )
                return i;
        }

        return -1;
    }

    // Return a scene object wrapper
    function findScene(sceneName)
    {
        var i = findSceneIndex(sceneName);
        return i >= 0 ? scenes[i] : null;
    }

    // Clear all the scenes from the sketch
    function clearScenes()
    {
        scene = null;
        scenes = [];
    }

    // Show the scene specified by name
    // The function justs sets the current scene... in order for the main loop to know what to call
    function showScene(sceneName, sceneArgs)
    {
        var o = findScene(sceneName);

        // Re-arm the enter function at each show of the scene
        o.enterExecuted = false;

        // inject sceneArgs as a property of the scene
        o.oScene.PublicVars.Arguments = sceneArgs;
        o.oScene.PublicVars.PreviousScene = scene != null ? scene.sceneName : "";

        scene = o;
    }


    // Show the next scene in the collection
    // Useful if implementing demo applications 
    // where you want to advance scenes automatically
    function showNextScene(sceneArgs)
    {
        if ( scenes.length == 0 )
            return;

        var nextSceneIndex = 0;

        if ( scene != null )
        {
            // search current scene... 
            // can be optimized to avoid searching current scene...
            var i = findSceneIndex( scene.sceneName );
            nextSceneIndex = i < scenes.length - 1 ? i + 1 : 0;
        }

        var nextScene = scenes[nextSceneIndex];
        showScene( nextScene.sceneName, sceneArgs );
    }


    // This is the main draw() dispatcher of the sketch...
    function draw()
    {
        // take the current scene in a variable to protect it in case
        // it gets changed by the user code in the events such as enter()...
        var currScene = scene;
        
        if ( currScene == null || currScene.oScene == null )
        {
            background("White");    // wipe the screen...
            return;
        }

        if ( currScene.hasEnter && !currScene.enterExecuted  )
        {
            currScene.oScene.enter();
            currScene.enterExecuted = true;
        }

        if ( currScene.hasLoop )
        {
            var bkArgs = currScene.oScene.PublicVars.SceneBackground;
            if (bkArgs == null)
                bkArgs = ["White"];

            background.apply(window, bkArgs);

            currScene.oScene.loop();

            // Call p5.play function to draw sprites...
            drawSprites();
        }
    }
 
    // Handle a certain even for a scene... 
    // It is used by the anonymous functions from the wire() function
    function handleEvent(sEvent)
    {
        if ( scene == null || scene.oScene == null )
            return;

        var fnSceneEvent = scene.oScene[sEvent];
        if (fnSceneEvent)
            fnSceneEvent();
    }

    function getPublicVars(sceneName)
    {
        var oSceneWrapper = findScene(sceneName);
        if (!oSceneWrapper)
            return null;

        var oScene = oSceneWrapper.oScene;
        if (!oScene)
            return null;

        return oScene.PublicVars;    
    }

    return { wire : wire, 
            addScene : addScene, 
            findScene : findScene,
            clearScenes : clearScenes,
            getPublicVars : getPublicVars,
            showScene : showScene,
            showNextScene : showNextScene }
}


function TestSketch()
{
    var scene1 = `
        background("lightyellow");
        var x = 0;

        PublicVars.MyName = "VMA";
        GlobalVars.MyName = "VMASOFT";

        function loop()
        {
            line(0, x, width, x);
            x = x + 1;

            if ( x == height )
                x = 0;

            text( "From " + PublicVars.PreviousScene + ": " + PublicVars.Arguments, 10, 10 );
        }

        function mouseClicked()
        {
            showScene("Scene2", x);
            //showNextScene(x);
        }
    `;


    var scene2 = `
        background("lightblue");
        var x = 0;

        function loop()
        {
            line(x, 0, x, height);
            x = x + 1;

            if ( x == width )
                x = 0;

            text( "From " + PublicVars.PreviousScene + ": " + PublicVars.Arguments, 10, 10 );
        }

        function mouseClicked()
        {
            var scene1Vars = getPublicVars("Scene1");
            console.log(scene1Vars.MyName);
            console.log(GlobalVars.MyName);
            
            showScene("Scene1", x);
            //showNextScene(x);
        }
    `;

    oSketch.addScene("Scene1", scene1);
    oSketch.addScene("Scene2", scene2);

    oSketch.showNextScene();
}



function CodeUtils()
{
    var arPublicEvents = ["loop", "enter"];
    var arPublicVars = [ "PublicVars" ];

    // Add specified events to the public events array
    // Usually: mouseClicked, keyPressed, ...
    function addP5Events(arEvents)
    {
        arPublicEvents = arPublicEvents.concat(arEvents);
    }

    // Returns true if the specified code contains the specified function
    // Works by doing text processing on the code
    function hasFunction(sCode, sFunctionName)
    {
        if (!sFunctionName || !sCode)
            return false;
        
        //TODO: Improve the logic for detecting if specified function is part of the code
        //to cover scenarios such as extra white spaces ... or the other declaration var loop = function()
        return sCode.indexOf("function " + sFunctionName + "()") >= 0;
    }


    // Returns an array with detected public events
    function detectEvents(sCode)
    {
        var arDetectedFunctions = [];

        if (arPublicEvents)
        {
            for(var i = 0; i < arPublicEvents.length; i++)
            {
                var fn = arPublicEvents[i];
                if(hasFunction(sCode, fn))
                    arDetectedFunctions.push(fn);
            }
        }

        return arDetectedFunctions;
    }


    // Returns the line of code that should represent the return from scene closure
    function getSceneReturnAsText(sCode)
    {
        var arDetectedFunctions = detectEvents(sCode);

        var sReturn = "return {";
        
        var n = arDetectedFunctions.length;

        for(var i = 0; i < n; i++) 
        {
            var fn = arDetectedFunctions[i];
            sReturn += fn + " : " + fn;
            if(i < n - 1)
                sReturn += ", ";
        }

        for(var i = 0; i < arPublicVars.length; i++)
        {
            if ( n > 0 || i > 0 )
                sReturn += ", ";
                sReturn += arPublicVars[i] + " : " + arPublicVars[i];
        }

        sReturn += "};"

        return sReturn;
    }

    function getScenePrefixCodeAsText()
    {
        return `
            var PublicVars = {};

            function background()
            {
                PublicVars.SceneBackground = arguments;
            }`;
    }


    // Converts the scene code to a function
    function getSceneFunction(sCode)
    {
        if (!sCode)
            return null;
        
        var sPrefixCode = getScenePrefixCodeAsText();
        var sReturnLine = getSceneReturnAsText(sCode);
        var sFnCode = sPrefixCode + "\n" + sCode + "\n" + sReturnLine + "\n";

        return new Function(sFnCode);
    }


/*
    // Returns the text of the Scene function (complete with the closure return line)
    function getSceneFunctionAsText(sCode, sFunctionName)
    {
        if (!sFunctionName || !sCode)
            return "";
        
        var sReturnLine = getSceneReturnAsText(sCode);

        return "function " + sFunctionName + "() {\n" + sCode + "\n" + sReturnLine + "\n}";
    }
*/

    return { addP5Events : addP5Events,
            getSceneFunction : getSceneFunction }
}



</script>
